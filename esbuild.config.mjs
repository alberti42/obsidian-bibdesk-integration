// esbuild.config.mjs

import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import copy from 'esbuild-plugin-copy';
import inline_web_workers from './esbuild-plugin-inline-workers.mjs'; // Import the plugin
import { promises as fs } from 'fs';

// Banner message for the generated/bundled files
const banner = `
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

// Determine whether to build for production or development
const prod = process.argv[2] === "production";

// Get the output directory
const outdir = 'dist';

const buildMain = async () => {
    // Set up rebuild logic
    const onWorkersRebuild = async () => {
        await context.rebuild();
    };

    // Start the main build process
    const context = await esbuild.context({
        banner: {
            js: banner,
        },
        entryPoints: ["src/main.ts"],
        bundle: true,
        external: [
            "obsidian",
            "electron",
            "@codemirror/autocomplete",
            "@codemirror/collab",
            "@codemirror/commands",
            "@codemirror/language",
            "@codemirror/lint",
            "@codemirror/search",
            "@codemirror/state",
            "@codemirror/view",
            "@lezer/common",
            "@lezer/highlight",
            "@lezer/lr",
            "original-fs",  // Mark original-fs as external so it's not bundled
            ...builtins
        ],
        format: "cjs",
        target: "es2022",
        logLevel: "info",
        sourcemap: prod ? false : "inline",
        minify: prod,
        minifySyntax: prod, // Enable syntax minification in production
        minifyWhitespace: prod, // Disable whitespace minification
        minifyIdentifiers: prod, // Disable identifier minification
        treeShaking: prod,
        outdir,
        plugins: [
            inline_web_workers(
                {
                    production: prod,
                    srcDir: './src',
                    onWorkersRebuild
                }),
            {   
                // We need to apply a workaround that replaces platform-specific imports like
                // fsevents. fsevents is a native module used only on macOS to provide efficient
                // file system watching. The goal was to ensure that chokidar doesn't rely on
                // fsevents and uses original-fs when deployed in Electron (specifically in
                // Obsidian, which runs on Electron). Changes: We replaced fsevents with null and
                // disabled the native FsEventsHandler to make chokidar platform-independent. We
                // also replaced fs with original-fs to maintain Electron compatibility.
                name: 'replace-fsevents',
                setup(build) {
                    // Hook into the resolve phase
                    build.onResolve({ filter: /fsevents/ }, () => {
                        return { path: 'null', namespace: 'fsevents' };
                    });

                    // Define what happens when the module is loaded
                    build.onLoad({ filter: /.*/, namespace: 'fsevents' }, () => {
                        return {
                            contents: `module.exports = null;`,
                            loader: 'js',
                        };
                    });

                    // Similarly replace the `require('fs')` with `require('original-fs')`
                    build.onLoad({ filter: /node_modules\/chokidar\/.*\.js$/ }, async (args) => {
                        let source = await fs.readFile(args.path, 'utf8');
                        source = source.replace(/const canUseFsEvents = FsEventsHandler\.canUse\(\);/g, 'const canUseFsEvents = false;');
                        source = source.replace(/require\('fsevents'\)/g, 'null');
                        source = source.replace(/require\('fs'\)/g, "require('original-fs')");
                        
                        return {
                            contents: source,
                            loader: 'js'
                        };
                    });
                }
            },
            copy({
                assets: {
                    from: ['./manifest.json'],
                    to: ['./manifest.json']
                }
            }),
            copy({
                assets: {
                    from: ['./styles/styles.css'],
                    to: ['./styles.css']
                }
            })
        ],
    });

    // Watch or build based on the environment
    if (prod) {
        await context.rebuild();
        process.exit(0);
    } else {
        // Watch for changes in development mode
        await context.watch();
    }
};

// Run the build process
buildMain().catch(() => process.exit(1));
